<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>General Sequences</TITLE>
<META NAME="description" CONTENT="General Sequences">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="manual.css">
</HEAD>
<BODY LANG="EN">
 <A NAME="tex2html2478" HREF="node47.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./icons/next_motif.gif"></A> <A NAME="tex2html2476" HREF="node45.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./icons/up_motif.gif"></A> <A NAME="tex2html2470" HREF="node45.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./icons/previous_motif.gif"></A> <A NAME="tex2html2480" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="./icons/contents_motif.gif"></A> <A NAME="tex2html2481" HREF="node153.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="./icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html2479" HREF="node47.html">Lists</A>
<B>Up:</B> <A NAME="tex2html2477" HREF="node45.html">SequencesArrays and Tables</A>
<B> Previous:</B> <A NAME="tex2html2471" HREF="node45.html">SequencesArrays and Tables</A>
<BR> <P>
<H2><A NAME="SECTION03071000000000000000">General Sequences</A></H2>
<P>
Vectors (one dimensional arrays) and lists are generic sequences.
A string is a sequence, since it is a vector of characters.
<P>
For the specification of result type in
<B>map, concatenate</B> and <B>coerce</B>,
use class name symbol, such as <TT>cons, string, integer-vector, float-vector</TT>,
etc. without quotes, 
since the class object is bound to the symbol.
<P>
<A NAME=5559>&#160;</A>
<B>elt</B> <EM>sequence pos </EM>[function] 
<UL><LI> <B>elt</B> is the most general function to get and put (in conjunction with
<B>setf</B>) value at the specific position <EM>pos in <EM>sequence</EM>.
<EM>Sequence</EM> may be a list, or a vector of arbitrary
object, bit, char, integer, or float.
<B>Elt</B> cannot be applied to a multi-dimensional array.
</UL>
<A NAME=5575>&#160;</A>
<B>length</B> <EM>sequence </EM>[function] 
<UL><LI> returns the length of <EM>sequence.
For vectors, <B>length</B> finishes in constant time, but
time proportional to the length is required for a list.
<B>Length</B> never terminates if <EM>sequence</EM> is a circular list.
Use <A NAME=5593>&#160;</A><B>l</B>ist-length, instead.
If <EM>sequence</EM> is an array with a fill-pointer, <B>length</B>
returns the fill-pointer, not the entire size of the array entity.
Use <B>array-total-size</B> to know the entire size of those arrays.
</UL>
<A NAME=5595>&#160;</A>
<B>subseq</B> <EM>sequence start [end] </EM>[function] 
<UL><LI> makes a copy of the subsequence from <EM>startth through  (<EM>end</EM>-1)th inclusively
out of <EM>sequence</EM>.
<EM>end</EM> is defaulted to the length of <EM>sequence</EM>.
</UL>
<A NAME=5610>&#160;</A>
<B>copy-seq</B> <EM>sequence </EM>[function] 
<UL><LI> does shallow-copying of <EM>sequence, that is, 
only the top-level references in <EM>sequence</EM> are copied.
Use <B>copy-tree</B> to copy a nested list,
or <B>copy-object</B> for deep-copying of a sequence
containing recursive references.
</UL>
<A NAME=5624>&#160;</A>
<B>reverse</B> <EM>sequence </EM>[function] 
<UL><LI> reverse the order of  <EM>sequence and returns a new sequence of the
same type as <EM>sequence</EM>.
</UL>
<A NAME=5636>&#160;</A>
<B>nreverse</B> <EM>sequence </EM>[function] 
<UL><LI> <B>Nreverse</B> is the destructive version of <B>reverse</B>.
<B>Nreverse</B> does not allocate memory, while <B>reverse</B> does.
</UL>
<A NAME=5650>&#160;</A>
<B>concatenate</B> <EM>result-type sequence* </EM>[function] 
<UL><LI> concatenates all <EM>sequences.
Each <EM>sequence may be of any sequence type.
Unlike <B>append</B>, all the sequences including the last one are copied.
<EM>Result-type</EM> should be a class such as cons, string,
vector, float-vector etc.
</UL>
<A NAME=5665>&#160;</A>
<B>coerce</B> <EM>sequence result-type </EM>[function] 
<UL><LI> changes the type of <EM>sequence.
For examples, <TT>(coerce '(a b c) vector) = #(a b c)</TT>  and 
<TT>(coerce &quot;ABC&quot; cons) = (a b c)</TT>.
A new sequence of type <EM>result-type</EM> is created, and each element of
<EM>sequence</EM> is copied to it.
<EM>result-type</EM> should be one of vector, integer-vector, float-vector,
bit-vector, string, cons or other user-defined classes inheriting 
one of these.
Note that <EM>sequence</EM> is copied even if its type equals to <EM>result-type</EM>.
</UL>
<A NAME=5683>&#160;</A>
<B>map</B> <EM>result-type function seq &amp;rest more-seqs </EM>[function] 
<UL><LI> <EM>function is applied to a list of arguments taken from <EM>seq</EM>
and <EM>more-seqs</EM> orderly, and the result is accumulated in a sequence
of type <EM>result-type</EM>.
</UL>
<A NAME=5697>&#160;</A>
<B>fill</B> <EM>sequence item &amp;key (:start 0) (:end (length sequence)) </EM>[function] 
<UL><LI> fills <EM>item from <EM>start</EM>th through (<EM>end</EM>-1)th in <EM>sequence</EM>.
<P>
</UL>
<A NAME=5711>&#160;</A>
<B>replace</B> <EM>dest source &amp;key :start1 :end1 :start2 :end2 </EM>[function] 
<UL><LI> elements in <EM>dest sequence indexed between <EM>start1</EM> and <EM>end1</EM>
are replaced with elements in <EM>source</EM> indexed between 
<EM>start2</EM> and <EM>end2</EM>.
<EM>start1</EM> and <EM>start2</EM> are defaulted to zero, and
<EM>end1</EM> and <EM>end2</EM> to the length of each sequence.
If the one of subsequences is longer than the other,
its end is truncated to match with the shorter subsequence.
</UL>
<A NAME=5731>&#160;</A>
<B>sort</B> <EM>sequence compare &amp;optional key </EM>[function] 
<UL><LI> <EM>sequence is destructively sorted using Unix's quick-sort subroutine.
<EM>key</EM> is not a keyword parameter.
Be careful with the sorting of a sequence which have same elements.
For example, <TT>(sort '(1 1) #'&gt;)</TT> fails because comparisons
between 1 and 1 in both direction fail.
To avoid this problem, use functions like #'&gt;= or #'&lt;= for comparison.
</UL>
<A NAME=5744>&#160;</A>
<B>merge</B> <EM>result-type seq1 seq2 pred &amp;key (key #'identity) </EM>[function] 
<UL><LI> two sequences <EM>seq1 and <EM>seq2</EM> are merged to form a single
sequence of <EM>result-type</EM> whose elements 
satisfy the comparison specified by <EM>pred</EM>.
</UL>
<A NAME=5758>&#160;</A>
<B>merge-list</B> <EM>list1 list2 pred key </EM>[function] 
<UL><LI> merges two lists. Unlike <B>merge</B> no general sequences are allowed 
for the arguments, but <B>merge-list</B> runs faster than <B>merge</B>.
</UL>
Following functions consist of one basic function and its variants
suffixed by -if and -if-not.
The basic form takes at least the item and sequence arguments,
and compares item with each element in the sequence,
and do some processing,
such as finding the index,
counting the number of appearances, removing the item, etc.
Variant forms take predicate and sequence arguments,
applies the predicate to each element of sequence, and do something
if the predicate returns non-nil (-if version), or nil (-if-not version).
<P>
<A NAME=5771>&#160;</A>
<B>position</B> <EM>item seq &amp;key :start :end :test :test-not :key (:count 1) </EM>[function] 
<UL><LI> finds <EM>countth appearance of <EM>item in <EM>seq</EM> and returns
its index.
The search begins from the <EM>start</EM>th element, ignoring elements before it.
By default, the search is performed by <B>eql</B>, which can be altered
by the <EM>test</EM> or <EM>test-not</EM> parameter.
</UL>
<A NAME=5788>&#160;</A>
<B>position-if</B> <EM>predicate seq &amp;key :start :end :key </EM>[function] 
<UL><LI> </UL>
<A NAME=5799>&#160;</A>
<B>position-if-not</B> <EM>predicate seq &amp;key :start :end :key </EM>[function] 
<UL><LI> </UL>
<A NAME=5810>&#160;</A>
<B>find</B> <EM>item seq &amp;key :start :end :test :test-not :key (:count 1) </EM>[function] 
<UL><LI> finds <EM>countth element between the <EM>startth element
and the <EM>endth element in <EM>seq</EM>.
The element found, which is eql to <EM>item</EM> if no <EM>test</EM> or
<EM>test-not</EM> other than #'eql is specified, is returned.
</UL>
<A NAME=5827>&#160;</A>
<B>find-if</B> <EM>predicate seq &amp;key :start :end :key (:count 1) </EM>[function] 
<UL><LI> finds <EM>countth element in <EM>seq</EM> for which <EM>pred</EM>
returns non nil.
</UL>
<A NAME=5840>&#160;</A>
<B>find-if-not</B> <EM>predicate seq &amp;key :start :end :key </EM>[function] 
<UL><LI> </UL>
<A NAME=5851>&#160;</A>
<B>count</B> <EM>item seq &amp;key :start :end :test :test-not :key </EM>[function] 
<UL><LI> counts the number of <EM>items which appear between the <EM>startth element
and the <EM>end</EM>th element in <EM>seq</EM>.
</UL>
<A NAME=5865>&#160;</A>
<B>count-if</B> <EM>predicate seq &amp;key :start :end :key </EM>[function] 
<UL><LI> count the number of elements in <EM>seq for which <EM>pred</EM> returns
non nil.
</UL>
<A NAME=5877>&#160;</A>
<B>count-if-not</B> <EM>predicate seq &amp;key :start :end :key </EM>[function] 
<UL><LI> </UL>
<A NAME=5888>&#160;</A>
<B>remove</B> <EM>item seq &amp;key :start :end :test :test-not :key :count </EM>[function] 
<UL><LI> creates a new sequence which has eliminated <EM>count (defaulted to infinity)
occurrences of of <EM>item(s) between the <EM>start</EM>th element
and the <EM>end</EM>th element in <EM>seq</EM>.
If you are sure that there is only one occurrence of <EM>item</EM>,
<EM>count=1</EM> should be specified to avoid meaningless scan over the whole
sequence.
</UL>
<A NAME=5905>&#160;</A>
<B>remove-if</B> <EM>predicate seq &amp;key :start :end :key :count </EM>[function] 
<UL><LI> </UL>
<A NAME=5916>&#160;</A>
<B>remove-if-not</B> <EM>predicate seq &amp;key :start :end :key :count </EM>[function] 
<UL><LI> </UL>
<A NAME=5927>&#160;</A>
<B>remove-duplicates</B> <EM>seq &amp;key :start :end :key :test :test-not :count </EM>[function] 
<UL><LI> removes duplicated items in <EM>seq and creates a new sequence.
</UL>
<A NAME=5938>&#160;</A>
<B>delete</B> <EM>item seq &amp;key :start :end :test :test-not :key :count </EM>[function] 
<UL><LI> is same with <B>remove</B> except that <B>delete</B> modifies <EM>seq
destructively and does not create a new sequence.
If you are sure that there is only one occurrence of <EM>item,
<EM>count=1 should be specified to avoid meaningless scan over the whole
sequence.
</UL>
<A NAME=5953>&#160;</A>
<B>delete-if</B> <EM>predicate seq &amp;key :start :end :key :count </EM>[function] 
<UL><LI> </UL>
<A NAME=5964>&#160;</A>
<B>delete-if-not</B> <EM>predicate seq &amp;key :start :end :key :count </EM>[function] 
<UL><LI> <EM>count for <EM>removes and <EM>delete</EM>s is defaulted to 1,000,000.
If you have a long sequence and you want to delete an element which
appears only once, :count should be specified as 1.
</UL>
<A NAME=5977>&#160;</A>
<B>substitute</B> <EM>newitem olditem seq
 &amp;key :start :end :test :test-not :key :count </EM>[function] 
<UL><LI> returns a new sequence which has 
substituted the <EM>count occurrence(s)
of <EM>olditem</EM> in <EM>seq</EM> with <EM>newitem</EM>.
By default, all the <EM>olditems</EM> are substituted.
</UL>
<A NAME=5992>&#160;</A>
<B>substitute-if</B> <EM>newitem predicate seq &amp;key :start :end :key :count </EM>[function] 
<UL><LI> </UL>
<A NAME=6003>&#160;</A>
<B>substitute-if-not</B> <EM>newitem predicate seq &amp;key :start :end :key :count </EM>[function] 
<UL><LI> </UL>
<A NAME=6014>&#160;</A>
<B>nsubstitute</B> <EM>newitem olditem seq &amp;key :start :end :test :test-not :key :count </EM>[function] 
<UL><LI> substitute the <EM>count occurrences of <EM>olditem in <EM>seq with <EM>newitem</EM>
destructively. By default, all the <EM>olditem</EM>s are substituted.
</UL>
<A NAME=6029>&#160;</A>
<B>nsubstitute-if</B> <EM>newitem predicate seq &amp;key :start :end :key :count </EM>[function] 
<UL><LI> </UL>
<A NAME=6040>&#160;</A>
<B>nsubstitute-if-not</B> <EM>newitem predicate seq &amp;key :start :end :key :count </EM>[function] 
<UL><LI> </UL>
<P>
</EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM><HR><A NAME="tex2html2478" HREF="node47.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./icons/next_motif.gif"></A> <A NAME="tex2html2476" HREF="node45.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./icons/up_motif.gif"></A> <A NAME="tex2html2470" HREF="node45.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./icons/previous_motif.gif"></A> <A NAME="tex2html2480" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="./icons/contents_motif.gif"></A> <A NAME="tex2html2481" HREF="node153.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="./icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html2479" HREF="node47.html">Lists</A>
<B>Up:</B> <A NAME="tex2html2477" HREF="node45.html">SequencesArrays and Tables</A>
<B> Previous:</B> <A NAME="tex2html2471" HREF="node45.html">SequencesArrays and Tables</A>
<P><ADDRESS>
<I>Hirofumi Nakagaki <BR>
Tue Mar 19 19:45:39 JST 1996</I>
</ADDRESS>
</BODY>
</HTML>
