<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Memory Management</TITLE>
<META NAME="description" CONTENT="Memory Management">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="manual.css">
</HEAD>
<BODY LANG="EN">
 <A NAME="tex2html2930" HREF="node76.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./icons/next_motif.gif"></A> <A NAME="tex2html2928" HREF="node74.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./icons/up_motif.gif"></A> <A NAME="tex2html2922" HREF="node74.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./icons/previous_motif.gif"></A> <A NAME="tex2html2932" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="./icons/contents_motif.gif"></A> <A NAME="tex2html2933" HREF="node153.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="./icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html2931" HREF="node76.html">Unix System Calls</A>
<B>Up:</B> <A NAME="tex2html2929" HREF="node74.html">System Functions</A>
<B> Previous:</B> <A NAME="tex2html2923" HREF="node74.html">System Functions</A>
<BR> <P>
<H2><A NAME="SECTION04011000000000000000">Memory Management</A></H2>
<P>
The design of  memory management scheme affects much to the flexibility and
efficiency of object-oriented languages.
EusLisp allocates memory to any sort of objects
in a unified manner based on the <EM>Fibonacci buddy method</EM>.
In this method, each of large memory pools called chunks is split into
small cells which are unequally sized but aligned at Fibonacci numbers.
A memory chunk is a homogeneous data container for any types of
objects such as <TT>symbol, cons, string, float-vector</TT>, etc.
as long as their sizes fit in the chunk.
A chunk has no special attributes,
like static, dynamic, relocatable, alternate, etc.
EusLisp's heap memory is the collection of chunks, and 
the heap can extend dynamically by getting new chunks from UNIX.
The expansion occurs either automatically on the fly
or on user's explicit demand by calling <B>system:alloc</B> function.
When it is managed automatically, free memory size is kept
about 25% of total heap size. This ratio can be changed by setting a value between 0.1 and 0.9 to
the <B>sys:*gc-margin*</B> parameter.
<P>
When all the heap memory is exhausted, mark-and-sweep type garbage collection
starts.
Cells accessible from the root (packages, classes and stacks) remain at the
same place where they were.
Other inaccessible cells are reclaimed and linked to the free-lists.
No copying or compactification occurs during GC.
When a garbage cell is reclaimed, its neighbor is checked
whether it is also free,
and they are merged together to form a larger cell if possible.
This merging, however, is sometimes meaningless,
since <TT>cons</TT>, which is the most frequently called memory allocator,
requests the merged cell to be divided to the smallest cell.
Therefore, EusLisp allows to leave a particular amount of heap unmerged to speed up cons.
This ratio is determined by <B>sys:*gc-merge*</B> parameter,
which is set to 0.3 by default.
With the larger <B>sys:*gc-merge*</B>, the larger heap is left unmerged.
This improves the performance of consing,
since buddy-cell splitting rarely occurs when conses are requested.
This is also true for every allocation of relatively small cells,
like three dimensional float-vectors.
<P>
<B>SYS:GC</B> invokes garbage collector explicitly, returning a list of two integers,
numbers of free words and total words (not bytes) allocated in the heap.
<P>
If &quot;fatal error: stack overflow&quot; is reported during  execution,
and you are convinced that the error is not caused by a infinite loop
or recursion, 
you can expand the size of the Lisp stack by <B>sys:newstack</B>.
<B>reset</B> should be performed before <B>sys:newstack</B>,
since it discards everything in the current stack such as
special bindings and clean-up forms of <EM>unwind-protect</EM>.
After a new stack is allocated, execution starts over from the point
of printing the opening message.
The default stack size is 16Kword.
The Lisp stack is different from the system stack.
The former is allocated in heap, while the latter is allocated in
the stack segment by the operating system.
If you get &quot;segmentation fault&quot; error, it might be caused by the shortage
of the system stack.
You can increase the system stack size by the <TT>limit</TT> csh command.
<P>
<B>sys:reclaim</B> and <B>sys:reclaim-tree</B> function put cells occupied by objects
back to the memory manager, so that they can be reused later without
invoking garbage collection.
You must be assured that there remains no reference to the cell.
<P>
<B>memory-report</B> and <B>room</B> function display statistics on 
memory usage sorted by cell sizes and classes respectively.
<P>
<B>address</B> returns the byte address of the object and is useful
as a hash function when used with hash-table, since this address is
unique in the process.
<P>
<B>Peek</B> and <B>poke</B> are the functions to read/write data directly
from/to a memory location.
The type of access should be either of
<B>:char, :byte, :short, :long, :integer, :float</B> and <B>:double</B>.
For an instance, <TT>(SYS:PEEK (+ 2 (SYS:ADDRESS '(a b))) :short)</TT>
returns class id of a cons cell, normally 1.
<P>
There are  several functions prefixed with 'list-all-'.
These functions returns the list of a system resource or environment,
and are useful for dynamic debugging.
<P>
<A NAME=11069>&#160;</A>
<B>sys:gc</B> <EM></EM>[function] 
<UL><LI> starts garbage collection, and returns a list of the numbers
of free words and total words allocated.
</UL>
<A NAME=11079>&#160;</A>
<B>sys:gctime</B> <EM></EM>[function] 
<UL><LI> returns a list of three integers: the count of gc invoked,
the time elapsed for marking cells (in 1/60 sec. unit),
and the time elapsed for reclamation (unmarking and merging).
</UL>
<A NAME=11089>&#160;</A>
<B>sys:alloc</B> <EM>size </EM>[function] 
<UL><LI> allocates at least <EM>size words of memory in the heap,
and returns the number of words really allocated.
</UL>
<A NAME=11100>&#160;</A>
<B>sys:newstack</B> <EM>size </EM>[function] 
<UL><LI> relinquishes the current stack,
and allocates a new stack of <EM>size words.
</UL>
<A NAME=11111>&#160;</A>
<B>sys:*gc-merge*</B> <EM></EM>[variable] 
<UL><LI> is a memory management parameter.
<B>*gc-merge*</B> is the ratio the ratio of heap memory  which is
left unmerged at GC.
This unmerged area will soon filled with smallest cells whose size is
the same as a cons.
The default value is 0.3.
The larger values, like 0.4, which specifies 40% of free heap should be
unmerged, favors for consing but do harm to instantiating
bigger cells like float-vectors, edges, faces, etc.
</UL>
<A NAME=11122>&#160;</A>
<B>sys:*gc-margin*</B> <EM></EM>[variable] 
<UL><LI> is a memory management parameter.
<B>*gc-margin</B> determines the ratio of
free heap size versus the total heap.
Memory is acquired from UNIX so that the free space does not go 
below this ratio. The default value 0.25 means that 25% of free space is
maintained at every GC.
</UL>
<A NAME=11133>&#160;</A>
<B>sys:reclaim</B> <EM>object </EM>[function] 
<UL><LI> relinquishes <EM>object as a garbage.
It must be guaranteed that it is no longer referenced from any other objects.
</UL>
<A NAME=11144>&#160;</A>
<B>sys:reclaim-tree</B> <EM>object </EM>[function] 
<UL><LI> reclaims all the objects except symbols traversable from <EM>object.
</UL>
<A NAME=11155>&#160;</A>
<B>sys:btrace</B> <EM>num </EM>[function] 
<UL><LI> prints the back-trace information of <EM>num depth on the Lisp stack.
</UL>
<A NAME=11166>&#160;</A>
<B>sys:memory-report</B> <EM>&amp;optional strm </EM>[function] 
<UL><LI> prints a table of memory usage report sorted by cell sizes
to the <I>strm</I> stream.
</UL>
<A NAME=11177>&#160;</A>
<B>sys:room</B> <EM>output-stream </EM>[function] 
<UL><LI> outputs memory allocation information ordered by classes.
</UL>
<A NAME=11187>&#160;</A>
<B>sys:address</B> <EM>object </EM>[function] 
<UL><LI> returns the address of <I>object</I> in the process memory space.
<P>
</UL>
<A NAME=11198>&#160;</A>
<B>sys:peek</B> <EM>[vector] address type </EM>[function] 
<UL><LI> reads data at the memory location specified by <EM>address
and returns it as an integer.
<EM>type is one of <B>:char, :byte, :short, :long, :integer, :float</B>,
and <B>:double</B>.
If no <EM>vector is given,
the address is taken in the unix's process space.
For example, since the a.out header is located at <TT>#x2000</TT> on SunOS4,
<TT>(sys:peek #x2000 :short)</TT> returns the magic number (usually <TT>#o403</TT>).
Solaris2 locates the ELF header at <TT>#10000</TT>,
and <TT>(sys:peek #x10000 :long)</TT> returns <TT>#xff454c46</TT> whose
string representation is &quot;ELF&quot;.
<P>
If <EM>vector, which might be a foreign-string,
is specified, address is recognized as an offset
from the vector's origin.
<TT>(sys:peek &quot;123456&quot; 2 :short)</TT> returns short word
representation of &quot;34&quot;, namely #x3334 (13108).
<P>
Be careful about the address alignment:
reading short, integer, long, float, double word
at odd address causes bus error.
</UL>
<A NAME=11221>&#160;</A>
<B>sys:poke</B> <EM>value [vector] address value type </EM>[function] 
<UL><LI> writes <I>value</I> at the location specified by <I>address</I>.
Special care should be taken since
you can write to anywhere in the process memory space.
Writing to outside the process space surely causes segmentation fault.
Writing short, integer, long, float, double word
at odd address causes bus error.
</UL>
<A NAME=11233>&#160;</A>
<B>sys:list-all-chunks</B> <EM></EM>[function] 
<UL><LI> list up all allocated heap chunks. Not useful for other than the implementor.
</UL>
<A NAME=11243>&#160;</A>
<B>sys:object-size</B> <EM>obj </EM>[function] 
<UL><LI> counts the number of cells and words accessible from <EM>obj.
All the objects reference-able from obj are traversed,
and a list of three numbers is returned:
the number of cells, 
the number of words logically allocated to these objects
(i.e. accessible from users),
and the number of words
physically allocated including headers and extra slots for memory management.
Traversing stops at symbols, i.e. objects referenced from a symbol such as
property-list or print-name string are not counted.
</UL>
<P>
</EM></EM></EM></EM></EM></EM></EM></EM></EM></EM><HR><A NAME="tex2html2930" HREF="node76.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./icons/next_motif.gif"></A> <A NAME="tex2html2928" HREF="node74.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./icons/up_motif.gif"></A> <A NAME="tex2html2922" HREF="node74.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./icons/previous_motif.gif"></A> <A NAME="tex2html2932" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="./icons/contents_motif.gif"></A> <A NAME="tex2html2933" HREF="node153.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="./icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html2931" HREF="node76.html">Unix System Calls</A>
<B>Up:</B> <A NAME="tex2html2929" HREF="node74.html">System Functions</A>
<B> Previous:</B> <A NAME="tex2html2923" HREF="node74.html">System Functions</A>
<P><ADDRESS>
<I>Hirofumi Nakagaki <BR>
Tue Mar 19 19:45:39 JST 1996</I>
</ADDRESS>
</BODY>
</HTML>
