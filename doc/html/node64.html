<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Evaluators</TITLE>
<META NAME="description" CONTENT="Evaluators">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="manual.css">
</HEAD>
<BODY LANG="EN">
 <A NAME="tex2html2708" HREF="node65.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./icons/next_motif.gif"></A> <A NAME="tex2html2706" HREF="node63.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./icons/up_motif.gif"></A> <A NAME="tex2html2700" HREF="node63.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./icons/previous_motif.gif"></A> <A NAME="tex2html2710" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="./icons/contents_motif.gif"></A> <A NAME="tex2html2711" HREF="node153.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="./icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html2709" HREF="node65.html">Top-level Interaction</A>
<B>Up:</B> <A NAME="tex2html2707" HREF="node63.html">Evaluation</A>
<B> Previous:</B> <A NAME="tex2html2701" HREF="node63.html">Evaluation</A>
<BR> <P>
<H2><A NAME="SECTION03091000000000000000">Evaluators</A></H2>
<P>
In order to specify the behaviors upon an error and an interrupt(signal),
set an appropriate function to each of the special variables
<B>*error-handler*</B> and <B>*signal-handler*</B> in advance.
There is no correctable or continue-able error.
After analyzing errors you must abort the current execution by
<B>reset</B> or appropriate <B>throw</B> to upper level catchers.
<B>reset</B> is equivalent to <TT>(throw 0 NIL)</TT>, since EusLisp's top-level
creates catch frame named <TT>0</TT>.
<P>
Error handlers should be programmed as functions with three or four
arguments:  <EM>code msg1 form &amp;optional (msg2)</EM>.
<EM>Code</EM> is the error code which identifies system defined errors,
such as 14 for 'mismatch argument' or 13 for 'undefined function'.
These mappings are described in &quot;c/eus.h&quot;.
<EM>msg1</EM> and <EM>msg1</EM> are messages displayed to the user.
<EM>form</EM> is the S-expression which caused the error.
<P>
Signal handlers should be programmed as functions receiving
two arguments: <EM>sig</EM> and <EM>code</EM>. 
<EM>Sig</EM> is the signal number ranging from 1 to 31, and <EM>code</EM>
is the minor signal code defined in signal-number dependent manners.
<P>
<code>^</code>D (<EM>end-of-file</EM>) at the top-level terminates eus session.
This is useful when eus is programmed as a filter.
<P>
<B>Eval-dynamic</B> is the function to find the dynamic value bound
to a symbol used as a let or lambda variable.
This is useful for debugging.
<P>
<A NAME=9383>&#160;</A>
<B>identity</B> <EM>obj </EM>[function] 
<UL><LI> returns obj itself.
Note the difference between <B>identity</B> and <B>quote</B>.
<B>identity</B> is a function whereas <B>quote</B> is a special form.
Therefore, <TT>(identity 'abc)</TT> is evaluated to <TT>abc</TT> and
<TT>(quote 'abc) == (quote (quote abc))</TT> is evaluated to <TT>'abc</TT>.
<B>Identity</B> is often used as the default value for <TT>:key</TT> parameters
of many generic sequence functions.
</UL>
<A NAME=9403>&#160;</A>
<B>eval</B> <EM>form [environment] </EM>[function] 
<UL><LI> evaluates <EM> form and returns its value.
Hook function can be called before entering the evaluation,
if <B>*evalhook*</B> is set to some function that accept form and environment.
</UL>
<A NAME=9415>&#160;</A>
<B>apply</B> <EM>func &amp;rest args </EM>[function] 
<UL><LI> <EM>func is applied to <EM>args.
<EM>Func</EM> must be evaluated to be a function symbol (a symbol which has
a function definition), a lambda form, or a closure.
Macros and special forms cannot be applied.
The last element of <EM>args</EM> must be a list of arguments while other args
should be bare arguments.
Thus, if the last <EM>args</EM> is NIL, then apply is almost equivalent to
funcall, except that apply has one more arguments than funcall.
<TT>(apply #'max 2 5 3 '(8 2)) -&gt; 8</TT>.
</UL>
<A NAME=9431>&#160;</A>
<B>funcall</B> <EM>func &amp;rest args </EM>[function] 
<UL><LI> applies <EM>func to <EM>args</EM>.
The number of <EM>args</EM> must coincide to the number of arguments
the <EM>func</EM> requests.
</UL>
<A NAME=9445>&#160;</A>
<B>quote</B> <EM>obj </EM>[special] 
<UL><LI> evaluates to <EM>obj itself.
</UL>
<A NAME=9456>&#160;</A>
<B>function</B> <EM>func </EM>[special] 
<UL><LI> makes a function closure.
If <EM>func is a symbol, its function definition is retrieved.
</UL>
<A NAME=9467>&#160;</A>
<B>evalhook</B> <EM>hookfunc form [env] </EM>[function] 
<UL><LI> evaluates <EM>form once after binding <EM>hookfunc</EM> to <B>*evalhook*</B>.
</UL>
<A NAME=9480>&#160;</A>
<B>eval-dynamic</B> <EM>variable </EM>[function] 
<UL><LI> finds the value of <EM>variable (symbol) on the stack.
</UL>
<A NAME=9491>&#160;</A>
<B>macroexpand</B> <EM>form </EM>[function] 
<UL><LI> expands <EM>form if it is a macro call.
If <EM>form</EM> is expanded to a macro call again, 
expansion is repeated until non macro call results.
</UL>
<A NAME=9503>&#160;</A>
<B>eval-when</B> <EM>situation {form}* </EM>[special] 
<UL><LI> Situation is a list of <TT>compile, load and eval</TT>.
Forms are evaluated when the current
execution mode matches with situation.
<B>eval-when</B> is important to control the behavior and environment
of the compiler.
If <TT>compile</TT> is specified, <EM>forms are evaluated by the compiler
so that the result will affect the consequent compilation.
For example, <EM>defmacro</EM> should be evaluated by the compiler
in order to let the compiler expand macro calls at compile time.
If <TT>load</TT> is given in the <EM>situation</EM> list,
<EM>forms</EM> are compiled to be loaded (evaluated) at load time,
i.e., compiled functions are defined at load time.
This is the normal effect that we expect to the compiler.
<TT>load</TT> situation is used to control the compiler's environment.
If <TT>eval</TT> is included in situation list, <EM>forms</EM>
are evaluated when their source code is loaded.
</UL>
<A NAME=9524>&#160;</A>
<B>the</B> <EM>type form </EM>[special] 
<UL><LI> Declares <EM>form is of <EM>type</EM>.
<EM>type</EM> is either a class object, :integer, :fixnum, or :float.
</UL>
<A NAME=9537>&#160;</A>
<B>declare</B> <EM>declaration* </EM>[special] 
<UL><LI> Each <EM>declaration is a list of a declaration specifier and an integer
or target symbols.
Declarations are important to let the compiler produce faster code.
<DL ><DT><DD> special declares special variables
<DT><DD> type declares the type of variables; <TT>(type integer count)</TT>;
valid type specifiers are <A NAME=9570>&#160;</A><EM>i</EM>nteger, <A NAME=9572>&#160;</A><EM>:</EM>integer <A NAME=9574>&#160;</A><EM>f</EM>ixnum,
<A NAME=9576>&#160;</A><EM>:</EM>float and  <A NAME=9578>&#160;</A><EM>f</EM>loat. The <B>type</B> keyword may be omitted
if type specifier is either one listed here. So <TT>(integer count)</TT>
is a correct declaration. Other types (classes) such as <EM>float-vector</EM>,
<EM>integer-vector</EM>, etc. need to be preceded by <B>type</B>, as
<TT>(type float-vector vec1)</TT>.
<DT><DD> ftype declares the result type of functions
<DT><DD> optimize set *optimize* parameter (0-3) of the compiler
<DT><DD> safety set *safety* parameter (0-3) of the compiler
<DT><DD> space  set *space* parameter (0-3) of the compiler
<DT><DD> inline not recognized
<DT><DD> not-inline not recognized
<P>
 </DL></UL>
<A NAME=9580>&#160;</A>
<B>proclaim</B> <EM>proclamation </EM>[function] 
<UL><LI> globally declares the types of variables and compiler options.
The same declarations are accepted as described for <B>declare</B> special form.
However, <B>proclaim</B> is a function of one argument and proclamation 
is evaluated.
</UL>
<A NAME=9592>&#160;</A>
<B>warn</B> <EM>format-string &amp;rest args </EM>[function] 
<UL><LI> prints warning-message given as <EM>format-string and <EM>args to
*error-output*.
</UL>
<A NAME=9604>&#160;</A>
<B>error</B> <EM>format-string &amp;rest args </EM>[function] 
<UL><LI> calls the current error-handler function bound to <B>*error-handler*</B>.
The default error-handler 'euserror' first
prints arguments to <B>*error-output*</B> using <B>format</B>,
then enters a new top level session.
The prompt shows you the depth of your error session.
<B>Throw</B>ing to the number, you can go back to the lower level error
session.
</UL>
In the multithread EusLisp, special variables are shared among threads
and the same <B>*error-handler*</B> is referenced by different threads.
To avoid this inconvenience, multithread EusLisp provides
the <B>install-error-handler</B> function which installs different
error handler for each thread.
<P>
<A NAME=9618>&#160;</A>
<B>install-error-handler</B> <EM>handler </EM>[function] 
<UL><LI> installs the <EM>handler as the error handler of the current thread.
</UL>
<P>
</EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM></EM><HR><A NAME="tex2html2708" HREF="node65.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./icons/next_motif.gif"></A> <A NAME="tex2html2706" HREF="node63.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./icons/up_motif.gif"></A> <A NAME="tex2html2700" HREF="node63.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./icons/previous_motif.gif"></A> <A NAME="tex2html2710" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="./icons/contents_motif.gif"></A> <A NAME="tex2html2711" HREF="node153.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="./icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html2709" HREF="node65.html">Top-level Interaction</A>
<B>Up:</B> <A NAME="tex2html2707" HREF="node63.html">Evaluation</A>
<B> Previous:</B> <A NAME="tex2html2701" HREF="node63.html">Evaluation</A>
<P><ADDRESS>
<I>Hirofumi Nakagaki <BR>
Tue Mar 19 19:45:39 JST 1996</I>
</ADDRESS>
</BODY>
</HTML>
